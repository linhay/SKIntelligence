//
//  Created by ktiays on 2025/2/12.
//  Copyright (c) 2025 ktiays. All rights reserved.
//

import Foundation
import JSONSchema

/// https://platform.openai.com/docs/api-reference/chat/object
public struct ChatResponseBody: Decodable {
    /// A list of chat completion choices.
    /// Can be more than one if `n` on `ChatCompletionRequestBody` is greater than 1.
    public var choices: [ChatChoice]

    /// The Unix timestamp (in seconds) of when the chat completion was created.
    public let created: Int

    /// The model used for the chat completion.
    public let model: String

    /// Usage statistics for the completion request.
    public let usage: ChatUsage?

    /// This fingerprint represents the backend configuration that the model runs with.
    /// Can be used in conjunction with the `seed` request parameter to understand when
    /// backend changes have been made that might impact determinism.
    public let systemFingerprint: String?

    private enum CodingKeys: String, CodingKey {
        case choices
        case created
        case model
        case usage
        case systemFingerprint = "system_fingerprint"
    }

    public init(choices: [ChatChoice], created: Int, model: String, usage: ChatUsage? = nil, systemFingerprint: String? = nil) {
        self.choices = choices
        self.created = created
        self.model = model
        self.usage = usage
        self.systemFingerprint = systemFingerprint
    }

    public init(from decoder: any Decoder) throws {
        let raw = try RawChatResponseBody(from: decoder)
        self.init(
            choices: raw.choices.map { $0.normalized() },
            created: raw.created,
            model: raw.model,
            usage: raw.usage,
            systemFingerprint: raw.systemFingerprint
        )
    }
}

public struct ChatChoice: Decodable {
    /// The reason the model stopped generating tokens. This will be `stop` if the model hit a
    /// natural stop point or a provided stop sequence, `length` if the maximum number of
    /// tokens specified in the request was reached, `content_filter` if content was omitted
    /// due to a flag from our content filters, `tool_calls` if the model called a tool, or
    /// `function_call` (deprecated) if the model called a function.
    public var finishReason: String?

    /// A chat completion message generated by the model.
    public var message: ChoiceMessage

    private enum CodingKeys: String, CodingKey {
        case finishReason = "finish_reason"
        case message
    }

    public init(finishReason: String? = nil, message: ChoiceMessage) {
        self.finishReason = finishReason
        self.message = message
    }
}

public struct ChoiceMessage: Decodable {
    /// The contents of the message.
    public var content: String?

    /// The reasoning behin the message.
    public var reasoning: String?
    public var reasoningContent: String?

    /// The role of the author of this message.
    public let role: String

    /// The tool calls generated by the model, such as function calls.
    public let toolCalls: [ToolCall]?

    private enum CodingKeys: String, CodingKey {
        case content
        case reasoning
        case reasoningContent = "reasoning_content"
        case role
        case toolCalls = "tool_calls"
    }

    public init(
        content: String? = nil,
        reasoning: String? = nil,
        reasoningContent: String? = nil,
        role: String,
        toolCalls: [ToolCall]? = nil
    ) {
        self.content = content
        self.reasoning = reasoning
        self.reasoningContent = reasoningContent
        self.role = role
        self.toolCalls = toolCalls
    }
}

public struct ToolCall: Decodable {
    /// The ID of the tool call.
    public let id: String

    /// The type of the tool. Currently, only `function` is supported.
    public let type: String

    /// The function that the model instructs us to call
    public let function: Function
}

public struct Function: Decodable {
    /// The name of the function to call.
    public let name: String

    /// The arguments to call the function with, as generated by the model in JSON format. Note
    /// that the model does not always generate valid JSON, and may hallucinate parameters not
    /// defined by your function schema. Validate the arguments in your code before calling
    /// your function.
    ///
    /// Implementor's note: I no longer think the above warning is true, now that this launched:
    /// https://openai.com/index/introducing-structured-outputs-in-the-api/
    ///
    /// The keys of the `[String: Any]` dictionary are the argument names, e.g. `location` in the guide below.
    /// The values of the `[String: Any]` dictionary are the arguments values, e.g. `BogotÃ¡, Colombia` in this guide:
    /// https://platform.openai.com/docs/guides/function-calling.
    public let arguments: [String: Any]?

    /// The raw arguments string, unmapped to a `[String: Any]`. The unmapped string is useful for
    /// continuing the converstation with the model. The model expects you to feed the raw argument string
    /// back to the model on susbsequent requests.
    public let argumentsRaw: String?

    private enum CodingKeys: CodingKey {
        case name
        case arguments
    }

    init(name: String, arguments: [String: Any]?, argumentsRaw: String?) {
        self.name = name
        self.arguments = arguments
        self.argumentsRaw = argumentsRaw
    }

    public init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        name = try container.decode(String.self, forKey: .name)
        let value = try container.decodeIfPresent(JSONValue.self, forKey: .arguments)
        let normalized = normalizeFunctionArguments(value)
        arguments = normalized.arguments
        argumentsRaw = normalized.argumentsRaw
    }
}

private struct RawChatResponseBody: Decodable {
    let choices: [RawChatChoice]
    let created: Int
    let model: String
    let usage: ChatUsage?
    let systemFingerprint: String?

    private enum CodingKeys: String, CodingKey {
        case choices
        case created
        case model
        case usage
        case systemFingerprint = "system_fingerprint"
    }
}

private struct RawChatChoice: Decodable {
    let finishReason: String?
    let message: RawChoiceMessage

    private enum CodingKeys: String, CodingKey {
        case finishReason = "finish_reason"
        case message
    }

    init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        finishReason = container.decodeLossyString(forKey: .finishReason)
        message = try container.decode(RawChoiceMessage.self, forKey: .message)
    }

    func normalized() -> ChatChoice {
        ChatChoice(finishReason: finishReason, message: message.normalized())
    }
}

private struct RawChoiceMessage: Decodable {
    let content: JSONValue?
    let reasoning: JSONValue?
    let reasoningContent: JSONValue?
    let role: String
    let toolCalls: [RawToolCall]?

    private enum CodingKeys: String, CodingKey {
        case content
        case reasoning
        case reasoningContent = "reasoning_content"
        case role
        case toolCalls = "tool_calls"
    }

    init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        role = try container.decode(String.self, forKey: .role)
        content = try container.decodeIfPresent(JSONValue.self, forKey: .content)
        reasoning = try container.decodeIfPresent(JSONValue.self, forKey: .reasoning)
        reasoningContent = try container.decodeIfPresent(JSONValue.self, forKey: .reasoningContent)

        let rawToolCalls = try container.decodeIfPresent(JSONValue.self, forKey: .toolCalls)
        toolCalls = normalizeToolCalls(rawToolCalls)
    }

    func normalized() -> ChoiceMessage {
        ChoiceMessage(
            content: normalizeMessageContent(content),
            reasoning: normalizeOptionalString(reasoning),
            reasoningContent: normalizeOptionalString(reasoningContent),
            role: role,
            toolCalls: toolCalls?.map { $0.normalized() }
        )
    }
}

private struct RawToolCall: Decodable {
    let id: String
    let type: String
    let function: RawFunction

    func normalized() -> ToolCall {
        ToolCall(id: id, type: type, function: function.normalized())
    }
}

private struct RawFunction: Decodable {
    let name: String
    let arguments: JSONValue?

    private enum CodingKeys: CodingKey {
        case name
        case arguments
    }

    init(from decoder: any Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        name = try container.decode(String.self, forKey: .name)
        arguments = try container.decodeIfPresent(JSONValue.self, forKey: .arguments)
    }

    func normalized() -> Function {
        let normalized = normalizeFunctionArguments(arguments)
        return Function(name: name, arguments: normalized.arguments, argumentsRaw: normalized.argumentsRaw)
    }
}

private struct NormalizedFunctionArguments {
    let arguments: [String: Any]?
    let argumentsRaw: String?
}

private func normalizeFunctionArguments(_ value: JSONValue?) -> NormalizedFunctionArguments {
    guard let value else {
        return .init(arguments: nil, argumentsRaw: nil)
    }

    switch value {
    case .null:
        return .init(arguments: nil, argumentsRaw: nil)
    case .string(let raw):
        return .init(arguments: parseObjectArguments(from: raw), argumentsRaw: raw)
    case .object(let object):
        return .init(
            arguments: object.untypedDictionary,
            argumentsRaw: canonicalJSONString(of: value)
        )
    default:
        return .init(arguments: nil, argumentsRaw: canonicalJSONString(of: value))
    }
}

private func parseObjectArguments(from raw: String) -> [String: Any]? {
    guard let data = raw.data(using: .utf8),
          let object = try? JSONDecoder().decode([String: JSONValue].self, from: data) else {
        return nil
    }
    return object.untypedDictionary
}

private func canonicalJSONString(of value: JSONValue) -> String? {
    let encoder = JSONEncoder()
    encoder.outputFormatting = [.sortedKeys]
    guard let data = try? encoder.encode(value) else {
        return nil
    }
    return String(data: data, encoding: .utf8)
}

private func normalizeToolCalls(_ value: JSONValue?) -> [RawToolCall]? {
    guard let value else {
        return nil
    }

    let calls: [RawToolCall]
    switch value {
    case .null:
        return nil
    case .array(let array):
        calls = array.compactMap { decodeDecodable(RawToolCall.self, from: $0) }
    case .object:
        calls = [value].compactMap { decodeDecodable(RawToolCall.self, from: $0) }
    default:
        calls = []
    }
    return calls.isEmpty ? nil : calls
}

private func normalizeMessageContent(_ value: JSONValue?) -> String? {
    guard let value else {
        return nil
    }

    switch value {
    case .null:
        return nil
    case .string(let text):
        return text
    case .array(let parts):
        let text = parts.compactMap(extractTextContent(from:)).joined()
        return text.isEmpty ? nil : text
    case .object:
        let text = extractTextContent(from: value)
        return text?.isEmpty == true ? nil : text
    default:
        return nil
    }
}

private func normalizeOptionalString(_ value: JSONValue?) -> String? {
    guard case .string(let text)? = value else {
        return nil
    }
    return text
}

private func extractTextContent(from value: JSONValue) -> String? {
    guard case .object(let object) = value else {
        return nil
    }

    if case .string(let text)? = object["text"] {
        return text
    }
    if case .object(let textObject)? = object["text"],
       case .string(let text)? = textObject["value"] {
        return text
    }
    return nil
}

private func decodeDecodable<T: Decodable>(_ type: T.Type, from value: JSONValue) -> T? {
    guard let data = try? JSONEncoder().encode(value) else {
        return nil
    }
    return try? JSONDecoder().decode(type, from: data)
}

private extension KeyedDecodingContainer {
    func decodeLossyString(forKey key: Key) -> String? {
        if let stringValue = try? decodeIfPresent(String.self, forKey: key) {
            return stringValue
        }
        if case .string(let value)? = try? decodeIfPresent(JSONValue.self, forKey: key) {
            return value
        }
        return nil
    }
}
